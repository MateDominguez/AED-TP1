\documentclass[10pt,a4paper]{article}

\input{AEDmacros}

\usepackage{caratula} % Version modificada para usar las macros de algo1 de ~> https://github.com/bcardiff/dc-tex


\titulo{Trabajo practico 1}
\subtitulo{Especificacion y Weakest Precondition}

\fecha{\today}

\materia{Algoritmos y Estructura de Datos}
\grupo{Grupo HIBTAYIGAFWKBCHZLZPJ}

\integrante{Dominguez, Mateo Felipe}{924/23}{matedominguez2@gmail.com}
\integrante{Apellido, Nombre2}{002/01}{email2@dominio.com}
\integrante{Apellido, Nombre3}{003/01}{email3@dominio.com}
\integrante{Apellido, Nombre4}{004/01}{email4@dominio.com}

% Declaramos donde van a estar las figuras
% No es obligatorio, pero suele ser comodo
\graphicspath{{../static/}}

\begin{document}

\maketitle

% Punto 1
\section{Especificacion}

% Especificacion punto 1.1
\subsection{grandesCiudades}
\begin{proc}{grandesCiudades}{\In ciudades: \TLista{Ciudad}}{\TLista{Ciudad}}
	\requiere{\neg ciudadesRepetidas(ciudades)}
	\asegura{\neg ciudadesRepetidas(res) \wedge (\forall i : \ent)(0 \leq i < |res| \implicaLuego res[i] \in ciudades \wedge res[i][1] > 50.000)}
\end{proc}

\vspace{0.3cm}

\pred{ciudadesRepetidas}{s: \TLista{Ciudad}}{(\forall i : \ent)(0 \leq i < |s| \implicaLuego (\exists j : \ent)(0 \leq j < |s| \wedge i \neq j \yLuego s[i] = s[j]))}

\vspace{0.3cm}

% Especificaion punto 1.2
\subsection{sumaDeHabitantes}
\begin{proc}{sumaDeHabitantes}{\In menoresDeCiudades: \TLista{Ciudad}, \In mayoresDeCiudades: \TLista{Ciudad}}{\TLista{Ciudad}}
	\requiere{\neg ciudadesRepetidas(menoresDeCiudades) \wedge \neg ciudadesRepetidas(mayoresDeCiudades)}
	\requiere{mismasCiudades(menoresDeCiudades, mayoresDeCiudades)}
	\asegura{|res| = |s_1|}
	\asegura{\neg ciudadesRepetidas(res)}
	\asegura{(\forall i,j : \ent)(0 \leq i,j < |menoresDeCiudades| \yLuego menoresDeCiudades[i][0] = mayoresDeCiudades[j][0] \implicaLuego (res[i][1] = menoresDeCiudades[i][1] + mayoresDeCiudades[j][1])))}
\end{proc}

\vspace{0.3cm}

\pred{mismasCiudades}{s: \TLista{Ciudad}, t: \TLista{Ciudad}}{(\forall i : \ent)(0 \leq i < |s_1| \implicaLuego (\exists j : \ent)(0 \leq j < |s_2| \yLuego s_1[i][0] = s_2[j][0]))}

\vspace{0.3cm}

% Especificacion punto 1.3
\subsection{hayCamino}
\begin{proc}{hayCamino}{\In distancias: \TLista{\TLista{\ent}}, \In desde: \ent, \In hasta: \ent}{Bool}
	\requiere{esCuadrada(distancias)}
	\requiere{(\forall i,j : \ent)(0 \leq i,j < |s| \implicaLuego s[i][j] = s[j][i] \wedge s[i][j] \geq 0)}
	\requiere{0 \leq desde,hasta < |distancias|}
	\asegura{res = True \iff (\exists t : \TLista{\ent})(esCamino(distancias, t, desde, hasta))}
\end{proc}

\vspace{0.3cm}

\pred{esCuadrada}{A : \TLista{\TLista{\ent}}}{(\forall i : \ent)(0 \leq i < |A| \implicaLuego |A[i]| = |A|)}
\vspace{0.1cm}
\pred{esCamino}{s: \TLista{\TLista{\ent}}, t: \TLista{\ent}, n: \ent, m: \ent}{(2 \leq |t| \leq |s| \wedge t[0] = n \wedge t[|t|-1] = m \wedge (\forall i : \ent)(0 \leq i < |t|-1 \implicaLuego 0 \leq t[i] < |s| \wedge s[t[i]][t[i+1]] > 0))}

\vspace{0.3cm}

% Especificaion punto 1.4
\subsection{cantidadCaminosNSaltos}
\begin{proc}{cantidadCaminosNSaltos}{\Inout conexion: \TLista{\TLista{\ent}}, \In n: \ent}{}
	\requiere{conexion = C_0}
	\requiere{esCuadrada(C_0)}
	\requiere{(\forall i,j : \ent)(0 \leq i,j < |C_0|\implicaLuego(C_0[i][j] = C_0[j][i]\wedge(C_0[i][j] = 0 \vee C_0[i][j] = 1)))}
	\requiere{(\forall i,j : \ent)(((0 \leq i,j < |C_0|)\wedge(i = j))\implicaLuego(C_0[i][j] = 0))}
	\requiere{n \geq 1}
	\asegura{|conexion| = |C_0|}
	\asegura{(\forall i,j : \ent)(0 \leq i,j < |conexion| \implicaLuego conexion[i][j] = conexion[j][i])}
	\asegura{(\exists t : \TLista{\TLista{\TLista{\ent}}})(|t| = n \wedge t[0] = C_0 \wedge (\forall i,j : \ent)(0 \leq i < |t| - 1 \wedge 0 \leq j < |t| \implicaLuego |t[i]|=|t[j]| \wedge \\ esCuadrada(t[j]) \wedge APorBEsC(t[i], C_0, t[i+1])) \wedge conexion = t[n-1])}
\end{proc}

\vspace{0.3cm}

\pred{APorBEsC}{A : \TLista{\TLista{\ent}}, B : \TLista{\TLista{\ent}}, C : \TLista{\TLista{\ent}}}{(\forall i,j : \ent)(0 \leq i,j < |C| \implicaLuego (C[i][j] = \sum\limits_{k=0}^{|C| - 1} A[i][k]*B[k][j]))}

\vspace{0.3cm}

% Especificacion punto 1.5
\subsection{caminoMinimo}
\begin{proc}{caminoMinimo}{\In origen: \ent, \In destino: \ent, \In distancias: \TLista{\TLista{\ent}}}{\TLista{\ent}}
	\requiere{esCuadrada(distancias)}
	\requiere{(\forall i,j : \ent)(0 \leq i,j < |s| \implicaLuego s[i][j] = s[j][i] \wedge s[i][j] \geq 0)}
	\requiere{0 \leq origen,destino < |distancias|}
	\asegura{res = \ensuremath{\langle\rangle} \iff \neg conectadas(distancias, origen, hasta)}
	\asegura{esCamino(distancias, res, origen, destino) \wedge esMinimo(distancias, res, origen, destino)}
\end{proc}

\vspace{0.3cm}

\pred{esMinimo}{s: \TLista{\TLista{\ent}}, t: \TLista{\ent}, n: \ent, m: \ent}{(\forall w: \TLista{\ent})(esCamino(s, w, n, m) \implicaLuego sumaDistancias(s,t) \leq sumaDistancias(s,w))}
\aux{sumaDistancias}{s: \TLista{\TLista{\ent}}, t: \TLista{\ent}}{\ent}{\sum\limits_{i=0}^{|t| - 2} s[t[i]][t[i+1]]}

\vspace{0.3cm}

% Punto 2
\section{Demostraciones de correctitud}
\begin{lstlisting}[label=implementacion-punto2]
	res = 0
	i = 0
	while (i < ciudades.length) do
		res = res + ciudades[i].habitantes
		i = i + 1
	endwhile
\end{lstlisting}

\vspace{0.3cm}

% Demostracion punto 2.1
\subsection{Demostrar que la implementacion es correcta con respecto a la especificacion}
\textbf{Demostrar \{P\}S\{Q\}}

\vspace{0.1cm}

\noindent Supongamos ciudades = [(a,10),(b,15)]

\begin{table}[h!]
	\begin{tabular}{| l | l | l |} 
		\hline
		Iteracion & i & res  \\ [0.5ex] 
		\hline
		0 & 0 & 0 \\ 
		1 & 1 & 10 \\
		2 & 2 & 10+15=25 \\
		\hline
	\end{tabular}
	\captionsetup{singlelinecheck=off}
	\caption{Tabla de iteracion}
	\label{tab:iteracion}
\end{table}

$I \equiv 0 \leq i \leq |ciudades| \wedge res = \sum\limits_{j=0}^{i-1} ciudades[j].habitantes$

$ P_c \equiv res = 0 \wedge i = 0$

$ Q_c \equiv res = \sum\limits_{i=0}^{|c|-1} ciudades[i].habitantes$

$ B \equiv i < |ciudades|$

\vspace{0.3cm}

% Paso 1
\textbf{Paso 1}

\vspace{0.1cm}

\noindent$P_c \implies I \ ? \\ res = 0 \wedge i = 0 \implies 0 \leq i < |ciudades| \wedge res = \sum\limits_{j=0}^{i-1} ciudades[j].habitantes$

Analizamos variable a variable: \\ $\bullet \ i = 0 \implies 0 \leq i < |ciudades| \\ \bullet \ res = \sum\limits_{j=0}^{i-1} ciudades[j].habitantes = \sum\limits_{j=0}^{-1} ciudades[j].habitantes = 0 \implies res = 0 $

\vspace{0.3cm}

% Paso 2
\textbf{Paso 2}

\vspace{0.1cm}

\noindent$\{I \wedge B\} S \{I\} \\ \{I \wedge B\} \implies wp(S,I) \ ?$

\noindent$\bullet \ \{I \wedge B\} = \{0 \leq i < |ciudades| \wedge \sum\limits_{j=0}^{i-1} ciudades[j].habitantes\} \\ \bullet \ wp(S_1;S_2,I) = wp(S_1,wp(S_2,I))$

\noindent$wp(S_2,I) = wp(i := i + i, 0 \leq i \leq |ciudades| \wedge res = \sum\limits_{j=0}^{i-1} ciudades[j].habitantes) \equiv \\ def(i+1) \yLuego 0 \leq i+1 \leq |ciudades| \yLuego res = \sum\limits_{j=0}^{i} ciudades[j].habitantes \equiv \\ 0 \leq i+1 \leq |ciudades| \wedge res = \sum\limits_{j=0}^{i} ciudades[j].habitantes$

\vspace{0.3cm}

\noindent$wp(S_1,wp(S_2,I)) \equiv wp(res := res + ciudades[i].habitantes, 0 \leq i+1 \leq |ciudades| \wedge res = \sum\limits_{j=0}^{i} ciudades[j].habitantes) \equiv \\ def(ciudades) \wedge def(ciudades[i].habitantes) \yLuego 0 \leq i+1 \leq |ciudades| \yLuego res + ciudades[i].habitantes= \sum\limits_{j=0}^{i} ciudades[j].habitantes \equiv \\ 0 \leq i < |ciudades| \wedge 0 \leq i+1 \leq |ciudades| \wedge res + ciudades[i].habitantes= \sum\limits_{j=0}^{i} ciudades[j].habitantes \equiv \\ 0 \leq i \leq |ciudades| - 1 \wedge res + ciudades[i].habitantes = \sum\limits_{j=0}^{i} ciudades[j].habitantes \equiv \\ 0 \leq i \leq |ciudades| - 1 \wedge res = \sum\limits_{j=0}^{i} ciudades[j].habitantes - ciudades[i].habitantes \equiv \\ 0 \leq i \leq |ciudades| - 1 \wedge res = \sum\limits_{j=0}^{i-1} ciudades[j].habitantes$

\vspace{0.3cm}

% Paso 3
\textbf{Paso 3}

\vspace{0.1cm}

\noindent$I \wedge \neg B \implies Q \ ? \\ (0 \leq i < |ciudades| \wedge res = \sum\limits_{j=0}^{i-1} ciudades[j].habitantes \wedge i \geq |ciudades|) \implies res = \sum\limits_{j=0}^{|c|-1} ciudades[j].habitantes \equiv \\ (i = |ciudades| \wedge res = \sum\limits_{j=0}^{i-1} ciudades[j].habitantes) \implies res = \sum\limits_{j=0}^{|c|-1} ciudades[j].habitantes \equiv \\ res = \sum\limits_{j=0}^{|c|-1} ciudades[j].habitantes \implies res = \sum\limits_{j=0}^{|c|-1} ciudades[j].habitantes $

\vspace{0.3cm}

%teorema de terminacion
\textbf{Teorema de terminacion}

\vspace{0.1cm}

\textbf{Paso 1}

\vspace{0.1cm}

\noindent$\{I \wedge B \wedge f_v = v_0\}S\{f_v < v_0\} \\ Verificamos \forall v_0, wp(S,f_v < v_0) \\ wp(S_1,wp(S_2,f_v < v_0))$

\noindent$ f_v = |ciudades| - 1 $

\vspace{0.3cm}

\noindent$ wp(S1,wp(S2,f_v<0)) \\  wp(res := res + ciudades[i].habitantes,wp(i := i + 1,|ciudades| - 1< V_0)) \equiv \\ wp(res := res + ciudades[i].habitantes, def (i) \wedge def(1)) \yLuego |ciudades|-(i + 1) < V_0 \equiv \\ wp(res := res + ciudades[i].habitantes,|ciudades|- i - 1 <  V_0) \equiv \\ def(res) \wedge def(ciudades) \wedge 0 \leq i < |ciudades| \yLuego |ciudades|- i - 1  V_0 \equiv \\ 0 \leq i < |ciudades| \yLuego |ciudades|- i - 1 < |ciudades| \equiv True $

\vspace{0.3cm}

\textbf{Paso 2}

\vspace{0.1cm}

\noindent$\{I \wedge f_v < 0\} \implies \neg B$

\noindent$ 0 \leq i < |ciudades| \wedge res = \sum\limits_{j=0}^{i-1} ciudades.[i].habitantes \wedge |ciudades| - i < 0 \implies i >= |ciudades| \equiv \\ i < |ciudades| \wedge res = \sum\limits_{j=0}^{i-1} ciudades.[i].habitantes \wedge |ciudades| < i \implies i >= |ciudades| \equiv \\ i = |ciudades| \wedge res = \sum\limits_{j=0}^{i-1} ciudades.[i].habitantes \implies i >= |ciudades| \equiv \\ i = |ciudades| \implies i >= |ciudades| $



% Demostracion paso 2.2
\subsection{Demostrar que el valor devuelto es mayor a 50.000}

\vspace{0.3cm}

\end{document}